"""
================================================================================
Minisum Multiple Facility Location Problem (Rectilinear Distance)
Coordinate Descent + Weighted Median Method
Based on IIT Kharagpur lecture notes (Dr. J. K. Jha)
================================================================================
"""

import numpy as np
import pulp

# ------------------------------------------------------------------------------
# Helper: weighted median
# ------------------------------------------------------------------------------

def weighted_median(values, weights):
    data = sorted(zip(values, weights), key=lambda x: x[0])
    total_w = sum(weights)
    cum_w = 0

    for v, w in data:
        cum_w += w
        if cum_w >= total_w / 2:
            return v


# ------------------------------------------------------------------------------
# Objective function (L1 minisum)
# ------------------------------------------------------------------------------

def minisum_cost(X, existing, w_ji, v_jk):
    """
    X        : list of (xj, yj) for new facilities
    existing : list of (ai, bi)
    w_ji     : weight matrix (n x m)
    v_jk     : interaction matrix (n x n)
    """
    cost = 0.0
    n = len(X)
    m = len(existing)

    # New–existing interactions
    for j in range(n):
        xj, yj = X[j]
        for i in range(m):
            ai, bi = existing[i]
            cost += w_ji[j][i] * (abs(xj - ai) + abs(yj - bi))

    # New–new interactions
    for j in range(n):
        for k in range(j + 1, n):
            xj, yj = X[j]
            xk, yk = X[k]
            cost += v_jk[j][k] * (abs(xj - xk) + abs(yj - yk))

    return cost


# ------------------------------------------------------------------------------
# Coordinate Descent Solver
# ------------------------------------------------------------------------------

def solve_minisum_mfl(existing, w_ji, v_jk, max_iter=50, tol=1e-6):
    """
    Coordinate Descent Algorithm for Minisum MFL (Rectilinear)

    Returns:
        dict with keys:
        - X_opt : optimal new facility locations
        - history : list of iterations
    """

    m = len(existing)
    n = len(w_ji)

    # -----------------------------
    # Step 0: Initial solution
    # (set v_jk = 0 → independent SFL)
    # -----------------------------
    X = []

    for j in range(n):
        a_vals = [existing[i][0] for i in range(m)]
        b_vals = [existing[i][1] for i in range(m)]
        weights = w_ji[j]

        x0 = weighted_median(a_vals, weights)
        y0 = weighted_median(b_vals, weights)
        X.append([x0, y0])

    history = [X.copy()]

    # -----------------------------
    # Iterations
    # -----------------------------
    for _ in range(max_iter):
        X_old = [tuple(p) for p in X]

        for t in range(n):
            # Build artificial data for NF t
            a_vals = []
            b_vals = []
            weights = []

            # Existing facilities
            for i in range(m):
                a_vals.append(existing[i][0])
                b_vals.append(existing[i][1])
                weights.append(w_ji[t][i])

            # Other new facilities
            for k in range(n):
                if k != t:
                    a_vals.append(X[k][0])
                    b_vals.append(X[k][1])
                    weights.append(v_jk[t][k])

            # Update location using weighted median
            X[t][0] = weighted_median(a_vals, weights)
            X[t][1] = weighted_median(b_vals, weights)

        history.append([tuple(p) for p in X])

        # Convergence check
        diff = sum(
            abs(X[t][0] - X_old[t][0]) + abs(X[t][1] - X_old[t][1])
            for t in range(n)
        )

        if diff < tol:
            break

    return {
        "X_opt": [tuple(p) for p in X],
        "history": history,
        "obj": minisum_cost(X, existing, w_ji, v_jk),
    }

# ------------------------------------------------------------------------------
# LP Solver (Rectilinear)
# ------------------------------------------------------------------------------

def solve_minisum_mfl_lp(existing, w_ji, v_jk):
    """
    Solves the Minisum MFL with Rectilinear distance using Linear Programming.
    Decomposes the problem into independent X and Y models.
    """
    m = len(existing)
    n = len(w_ji)
    
    # Internal helper to solve for one dimension (x or y)
    def solve_1d(coords, weights_ef, weights_nf):
        # Create LP Problem
        prob = pulp.LpProblem("Minisum_MFL_1D", pulp.LpMinimize)
        
        # --- Decision Variables ---
        # Coordinate variables for New Facilities (unrestricted)
        x = [pulp.LpVariable(f"x_{j}", lowBound=None) for j in range(n)]
        
        # Auxiliary variables for EF-NF interactions (r_ji, s_ji >= 0)
        # r_ji: amount NF j is to the right of EF i
        # s_ji: amount NF j is to the left of EF i
        r = [[pulp.LpVariable(f"r_{j}_{i}", lowBound=0) for i in range(m)] for j in range(n)]
        s = [[pulp.LpVariable(f"s_{j}_{i}", lowBound=0) for i in range(m)] for j in range(n)]
        
        # Auxiliary variables for NF-NF interactions (p_jk, q_jk >= 0)
        # p_jk: amount NF j is to the left of NF k
        # q_jk: amount NF j is to the right of NF k
        p_aux = [[None for k in range(n)] for j in range(n)]
        q_aux = [[None for k in range(n)] for j in range(n)]
        
        # We only need p, q for j < k
        for j in range(n):
            for k in range(j + 1, n):
                p_aux[j][k] = pulp.LpVariable(f"p_{j}_{k}", lowBound=0)
                q_aux[j][k] = pulp.LpVariable(f"q_{j}_{k}", lowBound=0)

        # --- Objective Function ---
        # Sum of weighted distances: w_ji * (r + s) + v_jk * (p + q)
        obj_ef = pulp.lpSum(weights_ef[j][i] * (r[j][i] + s[j][i]) for j in range(n) for i in range(m))
        obj_nf = pulp.lpSum(weights_nf[j][k] * (p_aux[j][k] + q_aux[j][k]) for j in range(n) for k in range(j+1, n))
        
        prob += obj_ef + obj_nf

        # --- Constraints ---
        # 1. EF-NF constraints: x_j - r_ji + s_ji = a_i
        for j in range(n):
            for i in range(m):
                prob += x[j] - r[j][i] + s[j][i] == coords[i]
        
        # 2. NF-NF constraints: x_j - x_k + p_jk - q_jk = 0  (for j < k)
        for j in range(n):
            for k in range(j + 1, n):
                prob += x[j] - x[k] + p_aux[j][k] - q_aux[j][k] == 0
        
        # Solve
        # Use simple solver, suppress log output
        prob.solve(pulp.PULP_CBC_CMD(msg=0))
        
        # Extract results
        res_x = [pulp.value(var) for var in x]
        
        # Extract active constraints for interpretation
        # If r_ji and s_ji are both approx 0, then x_j coincides with a_i
        active_ef = []
        for j in range(n):
            for i in range(m):
                val_r = pulp.value(r[j][i])
                val_s = pulp.value(s[j][i])
                if abs(val_r) < 1e-5 and abs(val_s) < 1e-5:
                    active_ef.append((j, i)) # NF j coincides with EF i
                    
        active_nf = []
        for j in range(n):
            for k in range(j + 1, n):
                val_p = pulp.value(p_aux[j][k])
                val_q = pulp.value(q_aux[j][k])
                if abs(val_p) < 1e-5 and abs(val_q) < 1e-5:
                    active_nf.append((j, k)) # NF j coincides with NF k

        return res_x, pulp.value(prob.objective), active_ef, active_nf

    # Prepare data
    a_coords = [p[0] for p in existing]
    b_coords = [p[1] for p in existing]
    
    # Solve X and Y independently
    x_opt, obj_x, act_ef_x, act_nf_x = solve_1d(a_coords, w_ji, v_jk)
    y_opt, obj_y, act_ef_y, act_nf_y = solve_1d(b_coords, w_ji, v_jk)
    
    # Combine results
    X_opt = list(zip(x_opt, y_opt))
    total_obj = obj_x + obj_y
    
    return {
        "X_opt": X_opt,
        "obj": total_obj,
        "active_constraints": {
            "x": {"ef": act_ef_x, "nf": act_nf_x},
            "y": {"ef": act_ef_y, "nf": act_nf_y}
        }
    }