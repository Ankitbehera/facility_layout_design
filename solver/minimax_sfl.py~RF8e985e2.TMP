"""
================================================================================
Minimax Single Facility Location Problem (Rectilinear / L1)
================================================================================
"""

import numpy as np
import matplotlib.pyplot as plt
import random
import math
from streamlit_plotly_events import plotly_events
import plotly.graph_objects as go

# =============================================================================
# CORE SOLVER
# =============================================================================

def solve_minimax_sfl_L1(data):
    """
    Solve the Minimax Single Facility Location Problem using
    Rectilinear (L1) distance.

    Mathematical model:
        Minimize   Z
        Subject to |x - a_i| + |y - b_i| ≤ Z   for all i

    Parameters
    ----------
    data : list of tuples
        [(a1, b1), (a2, b2), ..., (am, bm)]

    Returns
    -------
    dict with keys:
        - Z       : optimal maximum distance
        - c_vals  : (c1, c2, c3, c4, c5)
        - segment : [(x1, y1), (x2, y2)] optimal line segment
    """
     # Transform coordinates
    s1 = np.array([a + b for a, b in data])
    s2 = np.array([-a + b for a, b in data])

    # Extreme values
    c1 = np.min(s1)
    c2 = np.max(s1)
    c3 = np.min(s2)
    c4 = np.max(s2)

    # Objective value
    c5 = max(c2 - c1, c4 - c3)
    Z = 0.5 * c5

    # Extreme optimal solutions
    x1 = 0.5 * (c1 - c3)
    y1 = 0.5 * (c1 + c3 + c5)

    x2 = 0.5 * (c2 - c4)
    y2 = 0.5 * (c2 + c4 - c5)

    return {
        "Z": Z,
        "c_vals": (c1, c2, c3, c4, c5),
        "segment": [(x1, y1), (x2, y2)]
    }

def solve_maximin_sfl_L1(data, search_margin=50, step=1):
    """
    Maximin Single Facility Location Problem (Rectilinear / L1)

    Geometric formulation:
        Z(x,y) = min{
            x + y - c1,
            x - y - c2,
            -x + y - c3,
            -x - y - c4
        }

    Notes:
    - Z(x,y) >= 0 always
    - Problem is always feasible
    - Without explicit bounds, problem may be unbounded
    - This solver returns a representative optimal point
      obtained via numerical maximization
    """

    import numpy as np

    # --------------------------------------------------
    # Compute c-values (geometric envelope)
    # --------------------------------------------------
    s1 = np.array([a + b for a, b in data])
    s2 = np.array([a - b for a, b in data])
    s3 = np.array([-a + b for a, b in data])
    s4 = np.array([-a - b for a, b in data])

    c1 = np.max(s1)
    c2 = np.max(s2)
    c3 = np.max(s3)
    c4 = np.max(s4)

    # --------------------------------------------------
    # Geometric maximin objective
    # --------------------------------------------------
    def Z_value(x, y):
        return min(
            x + y - c1,
            x - y - c2,
            -x + y - c3,
            -x - y - c4
        )

    # --------------------------------------------------
    # Define finite search window (for visualization)
    # --------------------------------------------------
    xs = [a for a, _ in data]
    ys = [b for _, b in data]

    xmin = min(xs) - search_margin
    xmax = max(xs) + search_margin
    ymin = min(ys) - search_margin
    ymax = max(ys) + search_margin

    best_Z = -float("inf")
    best_point = None

    for x in range(int(xmin), int(xmax) + 1, step):
        for y in range(int(ymin), int(ymax) + 1, step):
            Z = Z_value(x, y)
            if Z > best_Z:
                best_Z = Z
                best_point = (x, y)

    # Enforce nonnegativity (theoretical guarantee)
    best_Z = max(best_Z, 0)

    return {
        "Z": best_Z,
        "point": best_point,
        "c_vals": (c1, c2, c3, c4),
        "status": "geometric maximin (numerical)"
    }
# =============================================================================
# Minimax Equilidean (Elzinga-Hearn Algo.)
# =============================================================================

def dist(p, q):
    return math.hypot(p[0] - q[0], p[1] - q[1])


def circle_from_two_points(p, q):
    cx = (p[0] + q[0]) / 2
    cy = (p[1] + q[1]) / 2
    r = dist(p, q) / 2
    return (cx, cy, r)


def circle_from_three_points(p, q, r):
    ax, ay = p
    bx, by = q
    cx, cy = r

    d = 2 * (ax*(by-cy) + bx*(cy-ay) + cx*(ay-by))
    if abs(d) < 1e-12:
        return None

    ux = (
        (ax*ax + ay*ay)*(by-cy) +
        (bx*bx + by*by)*(cy-ay) +
        (cx*cx + cy*cy)*(ay-by)
    ) / d

    uy = (
        (ax*ax + ay*ay)*(cx-bx) +
        (bx*bx + by*by)*(ax-cx) +
        (cx*cx + cy*cy)*(bx-ax)
    ) / d

    center = (ux, uy)
    radius = dist(center, p)
    return (ux, uy, radius)


def contains(circle, p, eps=1e-9):
    cx, cy, r = circle
    return dist((cx, cy), p) <= r + eps


def solve_minimax_sfl_L2_elzinga_hearn(points):
    """ Minimax Single Facility Location Euclidean distance Elzinga–Hearn geometric algorithm """
    points = points[:]
    random.shuffle(points)

    c = circle_from_two_points(points[0], points[1])

    for i in range(len(points)):
        if not contains(c, points[i]):
            c = (points[i][0], points[i][1], 0.0)

            for j in range(i):
                if not contains(c, points[j]):
                    c = circle_from_two_points(points[i], points[j])

                    for k in range(j):
                        if not contains(c, points[k]):
                            temp = circle_from_three_points(
                                points[i], points[j], points[k]
                            )
                            if temp is not None:
                                c = temp

    return {"x": c[0], "y": c[1], "Z": c[2]}

# =============================================================================
# OBJECTIVE FUNCTION (FOR VERIFICATION)
# =============================================================================

def obj_minimax_L1(x, y, data):
    """
    Evaluate minimax objective value at a given point.
    """
    return max(abs(x - a) + abs(y - b) for a, b in data)
    
def obj_maximin_L1(x, y, data):
    """
    Evaluate maximin objective value at a given point.
    """
    return min(abs(x - a) + abs(y - b) for a, b in data)


# =============================================================================
# VISUALIZATION
# =============================================================================

def plot_minimax_solution_L1(data, result):
    """
    Plot demand points, optimal solution line segment, and extreme points
    with a black box frame and distinct star markers for Point 1 and Point 2.
    """
    # Color Palette
    color_ef = '#1f77b4'  # Professional Blue for Existing Facilities
    color_segment = '#FF0000' # Red for the optimal connecting line
    color_p1 = '##FF0000'  # Green Star for Point 1
    color_p2 = '#FF8C00'  # Orange Star for Point 2
    
    fig, ax = plt.subplots(figsize=(7, 7), dpi=100)

    # 1. Plot demand points (Existing Facilities)
    ef_coords = list(data)
    ef_xs = [p[0] for p in ef_coords]
    ef_ys = [p[1] for p in ef_coords]
    
    ax.scatter(ef_xs, ef_ys, c=color_ef, marker='o', s=50, label='Existing ($P_i$)', zorder=3)
    
    for i, (a, b) in enumerate(ef_coords, start=1):
        ax.text(a + 0.15, b + 0.15, f"$P_{{{i}}}$", fontsize=9, color='#154360')

    # 2. Plot optimal segment (The Solution Set)
    (x1, y1), (x2, y2) = result["segment"]

    ax.plot(
        [x1, x2], [y1, y2],
        color=color_segment,
        linewidth=3,
        alpha=0.6,
        linestyle='-',
        label="Optimal Location Set",
        zorder=2
    )

    # 3. Plot extreme optimal points as distinct Stars
    # Point 1 Star
    ax.scatter([x1], [y1], c=color_p1, marker='*', s=220, edgecolors='black', 
               linewidths=0.5, label="Point 1 $(x_1^*, y_1^*)$", zorder=4)
    
    # Point 2 Star (Different Color)
    ax.scatter([x2], [y2], c=color_p2, marker='*', s=220, edgecolors='black', 
               linewidths=0.5, label="Point 2 $(x_2^*, y_2^*)$", zorder=4)

    # 4. Annotate coordinates
    ax.text(x1, y1 - 0.6, f"({x1:.2f}, {y1:.2f})", fontsize=8, color=color_p1, fontweight='bold', ha='center')
    ax.text(x2, y2 + 0.6, f"({x2:.2f}, {y2:.2f})", fontsize=8, color=color_p2, fontweight='bold', ha='center')

    # 5. Formatting (Thin Black Box Theme)
    ax.set_aspect("equal", adjustable="datalim")
    ax.grid(True, linestyle=":", alpha=0.4)
    
    # Ensure a thin black box frame
    for spine in ax.spines.values():
        spine.set_visible(True)
        spine.set_color('black')
        spine.set_linewidth(0.8) # Thin black line
    
    ax.set_xlabel("x-coordinate", fontsize=10)
    ax.set_ylabel("y-coordinate", fontsize=10)
    ax.set_title("Minimax Single Facility Location (Rectilinear)", fontsize=11, pad=15)
    
    # Legend with no frame
    ax.legend(frameon=False, loc='best', fontsize=8)

    plt.tight_layout()
    return fig

def plot_minimax_solution_L2(data, result):
    fig, ax = plt.subplots(figsize=(6, 6))

    xs = [p[0] for p in data]
    ys = [p[1] for p in data]

    x_opt = result["x"]
    y_opt = result["y"]
    Z = result["Z"]

    # -----------------------------------------
    # Plot demand points
    # -----------------------------------------
    ax.scatter(xs, ys, c="black", s=40, label="Demand points", zorder=3)

    # Label demand points
    for i, (x, y) in enumerate(data):
        ax.text(x, y, f"P{i+1}", fontsize=9, ha="right", va="bottom")

    # -----------------------------------------
    # Identify defining points
    # -----------------------------------------
    tol = 1e-6
    defining_pts = [
        p for p in data
        if abs(((p[0] - x_opt)**2 + (p[1] - y_opt)**2)**0.5 - Z) <= tol
    ]

    if defining_pts:
        dx = [p[0] for p in defining_pts]
        dy = [p[1] for p in defining_pts]

        # Blue ring markers
        ax.scatter(
            dx,
            dy,
            s=120,
            facecolors="none",
            edgecolors="blue",
            linewidths=1.5,
            label="Defining points",
            zorder=4
        )

        # -----------------------------------------
        # Blue line joining defining points
        # -----------------------------------------
        if len(defining_pts) >= 2:
            # Close the loop if 3 points (triangle)
            x_line = dx + ([dx[0]] if len(defining_pts) == 3 else [])
            y_line = dy + ([dy[0]] if len(defining_pts) == 3 else [])

            ax.plot(
                x_line,
                y_line,
                color="blue",
                linewidth=1.5,
                linestyle="-",
                zorder=3.5,
                label="Defining-point connection"
            )

    # -----------------------------------------
    # Plot optimal facility
    # -----------------------------------------
    ax.scatter(
        x_opt,
        y_opt,
        c="red",
        s=70,
        label="Optimal facility",
        zorder=5
    )

    ax.text(
        x_opt,
        y_opt,
        f"({x_opt:.2f}, {y_opt:.2f})",
        fontsize=9,
        color="red",
        ha="left",
        va="bottom"
    )

    # -----------------------------------------
    # Draw covering circle
    # -----------------------------------------
    circle = plt.Circle(
        (x_opt, y_opt),
        Z,
        fill=False,
        linestyle="--",
        color="red",
        linewidth=2,
        label="Covering circle"
    )
    ax.add_patch(circle)

    # -----------------------------------------
    # Styling
    # -----------------------------------------
    ax.set_aspect("equal", adjustable="box")
    ax.grid(True, linestyle="--", alpha=0.6)
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_title("Minimax Euclidean Location (Elzinga–Hearn)")
    ax.legend(
        loc="right",
        bbox_to_anchor=(1.15, 1.15),
        frameon=False
    )

    return fig


def plot_minimax_solution_L2_interactive(data, result, show_labels=False):
    xs = [p[0] for p in data]
    ys = [p[1] for p in data]

    fig = go.Figure()

    fig.add_trace(
        go.Scatter(
            x=xs,
            y=ys,
            mode="markers+text" if show_labels else "markers",
            text=[f"P{i+1}" for i in range(len(xs))] if show_labels else None,
            textposition="top center",
            marker=dict(size=8, color="black"),
            name="Demand points"
        )
    )

    fig.add_trace(
        go.Scatter(
            x=[result["x"]],
            y=[result["y"]],
            mode="markers",
            marker=dict(size=10, color="red"),
            name="Optimal facility"
        )
    )

    theta = [i * 2 * math.pi / 200 for i in range(201)]
    fig.add_trace(
        go.Scatter(
            x=[result["x"] + result["Z"] * math.cos(t) for t in theta],
            y=[result["y"] + result["Z"] * math.sin(t) for t in theta],
            mode="lines",
            line=dict(dash="dash", color="red"),
            name="Covering circle"
        )
    )

    fig.update_layout(
        height=450,
        xaxis=dict(scaleanchor="y", scaleratio=1),
        showlegend=True
    )

    return fig
